/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * "Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.0 (the 'License').  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License."
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#import "atc.h"

/*
 * ------------------------- Critical Bandwidth -------------------------------
 */

static INLINE double criticalBandWidth(double f)
/* 
  Returns critical bandwidth in Hz at the given center-frequency in Hz.
  Reference: 
  B.C. Moore and B.R. Glasberg, "Formulae Describing Frequency Selectivity 
  as a Function of Frequency and Level, and Their Use in Calculating 
  Excitation Patterns," Hearing Research, vol. 28, pp. 209-225, 1987.
*/
{
    f *= 0.001;			/* Convert to kHz */
    return 6.23 * f * f + 93.4 * f + 28.5;
}

/*
 * ------------------ Critical Band Smoother Breakpoints ----------------------
 */

static int *breakBins=0;	/* Bins where CB enlarges */
static int nBreakBins=0;
static int *cbLo = 0;
static int *cbHi = 0;
static int *cbWidth = 0;
static int nCBs=0;

static void createBreakBins(void)
    /* Create frequency breakpoint table */
{
    int i,cbb = 0;
    int len,lenm1 = 1;
    nBreakBins=floor(FREQ_TO_BIN(criticalBandWidth(SAMPLING_RATE*0.5))+0.5)-1;
    breakBins = (int *) malloc(nBreakBins * sizeof(int));
    for (i=0; i<NSPEC; i++) {
	double cbw = criticalBandWidth(BIN_TO_FREQ(i));
	len = floor(FREQ_TO_BIN(cbw) + 0.5);	/* round */
	if (len < 1)
	  continue;
	if (len > lenm1) {
	    if ((len - lenm1) > 1) {
		fprintf(stderr,"CB smoother jumped by more than 1!\n");
		exit(-1);
	    }
	    if (cbb >= nBreakBins) {
		fprintf(stderr,"nBreakBins computed incorrectly\n");
		break;
	    }
	    breakBins[cbb++] = i; /* 1st length is 2 */
	    lenm1 = len;
	}
    }
    if (cbb < nBreakBins)
      fprintf(stderr,"nBreakBins = %d while we only used %d\n",
	      nBreakBins, cbb);
//#ifded DEBUG
//    writeInts(breakBins,nBreakBins,"breakBins.dat");
//#endif

}

/*
 * -------------------- Critical Band Pointers --------------------
 */
static INLINE int createCriticalBandPointers(int nspec)
{
    int i,len,cbbi,bb1,nbb;
    int nCBs = nspec;		/* actually much less */
    int *cbLoP = cbLo = (int *)malloc(nCBs * sizeof(int));
    int *cbHiP = cbHi = (int *)malloc(nCBs * sizeof(int));
    int *cbWidthP = cbWidth = (int *)malloc(nCBs * sizeof(int));

    if (!breakBins) 
      createBreakBins();

    bb1 = breakBins[cbbi=0];
    for (i=0; i<bb1; i++) {
	*cbLoP++ = *cbHiP++ = i;	/* CB = 1 bin in this bin range */
	*cbWidthP++ = 1;
    }
    nbb = breakBins[++cbbi];
    for (i=bb1,len=2; i<nspec; i+=len) {
	if (i >= nbb) {		/* enlarge CB width */
	    len++;
	    nbb = breakBins[++cbbi];
	}	
	*cbLoP++ = i;
	*cbHiP++ = i+len-1;
	*cbWidthP++ = len;
    }
    if ((*--cbHiP) > nspec) {
	*cbHiP = nspec;
	*--cbWidthP = *cbHiP - *--cbLoP;
    }
    nCBs = cbLoP - cbLo + 1;
    return nCBs;
}

void main(void)
{
    int i;
    FILE *fp;
    char *fileName = "cb.h";
    fprintf(stderr,"Creating critical-band data structures in %s . . . ",
	    fileName);
    fp = fopen(fileName,"w");
    if (fp == NULL)
      fp = stderr;
    fprintf(fp,"/* cb.h - critical-band pointers for use in atc.c \n");
    fprintf(fp," *\n");
    fprintf(fp," * DO NOT EDIT - generated by cb.c\n");
    fprintf(fp," */\n\n");

    nCBs = createCriticalBandPointers(NSPEC);

    fprintf(fp,"/* Number of critical bands */\n");
    fprintf(fp,"#define NCB %d\n\n",nCBs);

    fprintf(fp,"#ifndef ATCSOUND_VERSION\n");
    fprintf(fp,"/* Low bin-number of each critical band */\n");
    fprintf(fp,"static const int cbLo[] = {\n");
    for (i=0;i<nCBs-1;i++)
      fprintf(fp,"\t%d,\n",cbLo[i]);
    fprintf(fp,"\t%d};\n\n",cbLo[nCBs-1]);

    fprintf(fp,"/* Width in bins of each critical band */\n");
    fprintf(fp,"static const int cbWidth[] = {\n");
    for (i=0;i<nCBs-1;i++)
      fprintf(fp,"\t%d,\n",cbWidth[i]);
    fprintf(fp,"\t%d};\n",cbWidth[nCBs-1]);
    fprintf(fp,"#endif !ATCSOUND_VERSION\n\n");

#if 0
    fprintf(fp,"/* NCB+1 band limits assuming a 44.1 kHz sampling rate */\n");
    fprintf(fp,"static const float cbLimitsHz[] = {\n");
    fprintf(fp,"\t%10.3f,\n",0.0);
    for (i=1;i<nCBs;i++) {
	double lo = (double)cbLo[i] - 0.5; /* band edge is between bins */
	fprintf(fp,"\t%10.3f,\n",SAMPLING_RATE * lo / FRAME_SIZE);
    }
    fprintf(fp,"\t%10.3f};\n\n",0.5*SAMPLING_RATE);
#endif

    fprintf(fp,"/* Band centers assuming a 44.1 kHz sampling rate */\n");
    fprintf(fp,"#ifndef LIBSYS_VERSION\n");
    fprintf(fp,"static const float cbCentersHz[] = {\n");
    for (i=0;i<nCBs;i++) {
	double lo = (double)cbLo[i];
	double w = (double) (cbWidth[i] - 1);
	double c = lo + 0.5 * w;
	if (i==nCBs-1)
	  fprintf(fp,"\t%10.3f};\n\n",SAMPLING_RATE * c / FRAME_SIZE);
	else
	  fprintf(fp,"\t%10.3f,\n",SAMPLING_RATE * c / FRAME_SIZE);
    }

    fprintf(fp,"/* Band widths assuming a 44.1 kHz sampling rate */\n");
    fprintf(fp,"static const float cbWidthsHz[] = {\n");
    for (i=0;i<nCBs;i++) {
	double w = (double) cbWidth[i];
	if (i==nCBs-1)
	  fprintf(fp,"\t%10.3f};\n",SAMPLING_RATE * w / FRAME_SIZE);
	else
	  fprintf(fp,"\t%10.3f,\n",SAMPLING_RATE * w / FRAME_SIZE);
    }
    fprintf(fp,"#endif !LIBSYS_VERSION\n");

    fclose(fp);

    fprintf(stderr,"done. Output file closed.\n");
    exit(0);
}


