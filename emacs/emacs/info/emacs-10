This is Info file ../info/emacs, produced by Makeinfo version 1.68 from
the input file emacs.texi.


File: emacs,  Node: Non-Window Terminals,  Prev: Misc X,  Up: Frames

Non-Window Terminals
====================

   If your terminal does not have a window system that Emacs supports,
then it can display only one Emacs frame at a time.  However, you can
still create multiple Emacs frames, and switch between them.  Switching
frames on these terminals is much like switching between different
window configurations.

   Use `C-x 5 2' to create a new frame and switch to it; use `C-x 5 o'
to cycle through the existing frames; use `C-x 5 0' to delete the
current frame.

   Each frame has a number to distinguish it.  If your terminal can
display only one frame at a time, the selected frame's number N appears
near the beginning of the mode line, in the form `FN'.


File: emacs,  Node: International,  Next: Major Modes,  Prev: Frames,  Up: Top

International Character Set Support
***********************************

   Emacs supports a wide variety of international character sets,
including European variants of the Latin alphabet, as well as Chinese,
Devanagari (Hindi and Marathi), Ethiopian, Greek, IPA, Japanese, Korean,
Lao, Russian, Thai, Tibetan, and Vietnamese scripts.  These features
have been merged from the modified version of Emacs known as MULE (for
"MULti-lingual Enhancement to GNU Emacs")

* Menu:

* International Intro::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Single-Byte European Support::
                            You can pick one European character set
                            to use without multibyte characters.


File: emacs,  Node: International Intro,  Next: Enabling Multibyte,  Up: International

Introduction to International Character Sets
============================================

   The users of these scripts have established many more-or-less
standard coding systems for storing files.  Emacs internally uses a
single multibyte character encoding, so that it can intermix characters
from all these scripts in a single buffer or string.  This encoding
represents each non-ASCII character as a sequence of bytes in the range
0200 through 0377.  Emacs translates between the multibyte character
encoding and various other coding systems when reading and writing
files, when exchanging data with subprocesses, and (in some cases) in
the `C-q' command (see below).

   The command `C-h h' (`view-hello-file') displays the file
`etc/HELLO', which shows how to say "hello" in many languages.  This
illustrates various scripts.

   Keyboards, even in the countries where these character sets are used,
generally don't have keys for all the characters in them.  So Emacs
supports various "input methods", typically one for each script or
language, to make it convenient to type them.

   The prefix key `C-x <RET>' is used for commands that pertain to
multibyte characters, coding systems, and input methods.


File: emacs,  Node: Enabling Multibyte,  Next: Language Environments,  Prev: International Intro,  Up: International

Enabling Multibyte Characters
=============================

   You can enable or disable multibyte character support, either for
Emacs as a whole, or for a single buffer.  When multibyte characters are
disabled in a buffer, then each byte in that buffer represents a
character, even codes 0200 through 0377.  The old features for
supporting the European character sets, ISO Latin-1 and ISO Latin-2,
work as they did in Emacs 19.

   However, there is no need to turn off multibyte character support to
use ISO Latin-1 or ISO Latin-2; the Emacs multibyte character set
includes all the characters in these character sets, and Emacs can
translate automatically to and from either of these ISO codes.

   The mode line indicates whether multibyte character support is
enabled in the current buffer.  If it is, a colon appears near the
beginning of the mode line, preceding the place where stars appear when
the buffer is modified.  When multibyte characters are not enabled, the
colon does not appear.

   The command `C-x <RET> m' (`toggle-enable-multibyte-characters')
enables or disables multibyte character support for the current buffer.

   To turn off multibyte character support by default, execute this
Lisp expression:

     (setq-default enable-multibyte-characters nil)

   When multibyte characters are enabled, character codes 0200 (octal)
through 0377 (octal) are not valid in the buffer.  The valid non-ASCII
printing characters have codes that start from 0400.

   If you type a self-inserting character in the invalid range, Emacs
assumes you intended to use one of the ISO Latin-N character sets, and
converts it to the Emacs code representing that Latin-N character.  You
select *which* ISO Latin character set to use though your choice of
language environment (*note Language Environments::.).

   The same thing happens when you use `C-q' to enter an octal code in
this range.


File: emacs,  Node: Language Environments,  Next: Input Methods,  Prev: Enabling Multibyte,  Up: International

Language Environments
=====================

   All supported character sets are supported in Emacs buffers whenever
multibyte characters are enabled; there is no need to select a
particular language in order to display its characters in an Emacs
buffer.  However, it is important to select a "language environment" in
order to set various defaults.  The language environment really
represents a choice of preferred script (more or less) rather that a
choice of language.

   The language environment controls which coding systems to recognize
when reading text (*note Recognize Coding::.).  This applies to files,
incoming mail, netnews, and any other text you read into Emacs.  It may
also specify the default coding system to use when you create a file.
Each language environment also specifies a default input method.

   The command to select a language environment is `M-x
set-language-environment'.  It makes no difference which buffer is
current when you use this command, because the effects apply globally to
the Emacs session.  The supported language environments include:

     Chinese-BIG5, Chinese-CNS, Chinese-GB, Cyrillic-Alternativnyj,
     Cyrillic-ISO, Cyrillic-KOI8, Devanagari, English, Ethiopic, Greek,
     Hebrew, Japanese, Korean, Lao, Latin-1, Latin-2, Latin-3, Latin-4,
     Latin-5, Thai, Tibetan, and Vietnamese.

   Some operating systems let you specify the language you are using by
setting locale environment variables.  Emacs handles one common special
case of this: if your locale name for character types contains the
string `8859-N', Emacs automatically selects the corresponding language
environment.

   To display information about the effects of a certain language
environment LANG-ENV, use the command `C-h L LANG-ENV <RET>'
(`describe-language-environment').  This tells you which languages this
language environment is useful for, and lists the character sets,
coding systems, and input methods that go with it.  It also shows some
sample text to illustrate scripts used in this language environment.
By default, this command describes the chosen language environment.


File: emacs,  Node: Input Methods,  Next: Select Input Method,  Prev: Language Environments,  Up: International

Input Methods
=============

   An "input method" is a kind of character conversion designed
specifically for interactive input.  In Emacs, typically each language
has its own input method; sometimes several languages which use the same
characters can share one input method.  A few languages support several
input methods.

   The simplest kind of input method works by mapping ASCII letters into
another alphabet.  This is how the Greek and Russian input methods work.

   A more powerful technique is composition: converting sequences of
characters into one letter.  Many European input methods use composition
to produce a single non-ASCII letter from a sequence that consists of a
letter followed by accent characters.  For example, some methods convert
the sequence `'a' into a single accented letter.

   The input methods for syllabic scripts typically use mapping followed
by composition.  The input methods for Thai and Korean work this way.
First, letters are mapped into symbols for particular sounds or tone
marks; then, sequences of these which make up a whole syllable are
mapped into one syllable sign.

   Chinese and Japanese require more complex methods.  In Chinese input
methods, first you enter the phonetic spelling of a Chinese word (in
input method `chinese-py', among others), or a sequence of portions of
the character (input methods `chinese-4corner' and `chinese-sw', and
others).  Since one phonetic spelling typically corresponds to many
different Chinese characters, you must select one of the alternatives
using special Emacs commands.  Keys such as `C-f', `C-b', `C-n', `C-p',
and digits have special definitions in this situation, used for
selecting among the alternatives.  <TAB> displays a buffer showing all
the possibilities.

   In Japanese input methods, first you input a whole word using
phonetic spelling; then, after the word is in the buffer, Emacs converts
it into one or more characters using a large dictionary.  One phonetic
spelling corresponds to many differently written Japanese words, so you
must select one of them; use `C-n' and `C-p' to cycle through the
alternatives.

   Sometimes it is useful to cut off input method processing so that the
characters you have just entered will not combine with subsequent
characters.  For example, in input method `latin-1-postfix', the
sequence `e '' combines to form an `e' with an accent.  What if you
want to enter them as separate characters?

   One way is to type the accent twice; that is a special feature for
entering the separate letter and accent.  For example, `e ' '' gives
you the two characters `e''.  Another way is to type another letter
after the `e'--something that won't combine with that--and immediately
delete it.  For example, you could type `e e <DEL> '' to get separate
`e' and `''.

   Another method, more general but not quite as easy to type, is to use
`C-\ C-\' between two characters to stop them from combining.  This is
the command `C-\' (`toggle-input-method') used twice.  *Note Select
Input Method::.

   `C-\ C-\' is especially useful inside an incremental search, because
stops waiting for more characters to combine, and starts searching for
what you have already entered.

   The variables `input-method-highlight-flag' and
`input-method-verbose-flag' control how input methods explain what is
happening.  If `input-method-highlight-flag' is non-`nil', the partial
sequence is highlighted in the buffer.  If `input-method-verbose-flag'
is non-`nil', the list of possible characters to type next is displayed
in the echo area (but not when you are in the minibuffer).


File: emacs,  Node: Select Input Method,  Next: Coding Systems,  Prev: Input Methods,  Up: International

Selecting an Input Method
=========================

`C-\'
     Enable or disable use of the selected input method.

`C-x <RET> C-\ METHOD <RET>'
     Select a new input method for the current buffer.

`C-h I METHOD <RET>'
`C-h C-\ METHOD <RET>'
     Describe the input method METHOD (`describe-input-method').  By
     default, it describes the current input method (if any).

`M-x list-input-methods'
     Display a list of all the supported input methods.

   To choose an input method for the current buffer, use `C-x <RET>
C-\' (`select-input-method').  This command reads the input method name
with the minibuffer; the name normally starts with the language
environment that it is meant to be used with.  The variable
`current-input-method' records which input method is selected.

   Input methods use various sequences of ASCII characters to stand for
non-ASCII characters.  Sometimes it is useful to turn off the input
method temporarily.  To do this, type `C-\' (`toggle-input-method').
To reenable the input method, type `C-\' again.

   If you type `C-\' and you have not yet selected an input method, it
prompts for you to specify one.  This has the same effect as using `C-x
<RET> C-\' to specify an input method.

   Selecting a language environment specifies a default input method for
use in various buffers.  When you have a default input method, you can
select it in the current buffer by typing `C-\'.  The variable
`default-input-method' specifies the default input method (`nil' means
there is none).

   Some input methods for alphabetic scripts work by (in effect)
remapping the keyboard to emulate various keyboard layouts commonly used
for those scripts.  How to do this remapping properly depends on your
actual keyboard layout.  To specify which layout your keyboard has, use
the command `M-x quail-set-keyboard-layout'.

   To display a list of all the supported input methods, type `M-x
list-input-methods'.  The list gives information about each input
method, including the string that stands for it in the mode line.


File: emacs,  Node: Coding Systems,  Next: Recognize Coding,  Prev: Select Input Method,  Up: International

Coding Systems
==============

   Users of various languages have established many more-or-less
standard coding systems for representing them.  Emacs does not use
these coding systems internally; instead, it converts from various
coding systems to its own system when reading data, and converts the
internal coding system to other coding systems when writing data.
Conversion is possible in reading or writing files, in sending or
receiving from the terminal, and in exchanging data with subprocesses.

   Emacs assigns a name to each coding system.  Most coding systems are
used for one language, and the name of the coding system starts with the
language name.  Some coding systems are used for several languages;
their names usually start with `iso'.  There are also special coding
systems `no-conversion', `raw-text' and `emacs-mule' which do not
convert printing characters at all.

   In addition to converting various representations of non-ASCII
characters, a coding system can perform end-of-line conversion.  Emacs
handles three different conventions for how to separate lines in a file:
newline, carriage-return linefeed, and just carriage-return.

`C-h C CODING <RET>'
     Describe coding system CODING.

`C-h C <RET>'
     Describe the coding systems currently in use.

`M-x list-coding-systems'
     Display a list of all the supported coding systems.

   The command `C-h C' (`describe-coding-system') displays information
about particular coding systems.  You can specify a coding system name
as argument; alternatively, with an empty argument, it describes the
coding systems currently selected for various purposes, both in the
current buffer and as the defaults, and the priority list for
recognizing coding systems (*note Recognize Coding::.).

   To display a list of all the supported coding systems, type `M-x
list-coding-systems'.  The list gives information about each coding
system, including the letter that stands for it in the mode line (*note
Mode Line::.).

   Each of the coding systems that appear in this list--except for
`no-conversion', which means no conversion of any kind--specifies how
and whether to convert printing characters, but leaves the choice of
end-of-line conversion to be decided based on the contents of each file.
For example, if the file appears to use carriage-return linefeed between
lines, that end-of-line conversion will be used.

   Each of the listed coding systems has three variants which specify
exactly what to do for end-of-line conversion:

`...-unix'
     Don't do any end-of-line conversion; assume the file uses newline
     to separate lines.  (This is the convention normally used on Unix
     and GNU systems.)

`...-dos'
     Assume the file uses carriage-return linefeed to separate lines,
     and do the appropriate conversion.  (This is the convention
     normally used on Microsoft systems.)

`...-mac'
     Assume the file uses carriage-return to separate lines, and do the
     appropriate conversion.  (This is the convention normally used on
     the Macintosh system.)

   These variant coding systems are omitted from the
`list-coding-systems' display for brevity, since they are entirely
predictable.  For example, the coding system `iso-latin-1' has variants
`iso-latin-1-unix', `iso-latin-1-dos' and `iso-latin-1-mac'.

   The coding system `raw-text' is good for a file which is mainly
ASCII text, but may contain byte values above 127 which are not meant to
encode non-ASCII characters.  With `raw-text', Emacs copies those byte
values unchanged, and sets `enable-multibyte-characters' to `nil' in
the current buffer so that they will be interpreted properly.
`raw-text' handles end-of-line conversion in the usual way, based on
the data encountered, and has the usual three variants to specify the
kind of end-of-line conversion to use.

   In contrast, the coding system `no-conversion' specifies no
character code conversion at all--none for non-ASCII byte values and
none for end of line.  This is useful for reading or writing binary
files, tar files, and other files that must be examined verbatim.  It,
too, sets `enable-multibyte-characters' to `nil'.

   The easiest way to edit a file with no conversion of any kind is with
the `M-x find-file-literally' command.  This uses `no-conversion', and
also suppresses other Emacs features that might convert the file
contents before you see them.  *Note Visiting::.

   The coding system `emacs-mule' means that the file contains
non-ASCII characters stored with the internal Emacs encoding.  It
handles end-of-line conversion based on the data encountered, and has
the usual three variants to specify the kind of end-of-line conversion.


File: emacs,  Node: Recognize Coding,  Next: Specify Coding,  Prev: Coding Systems,  Up: International

Recognizing Coding Systems
==========================

   Most of the time, Emacs can recognize which coding system to use for
any given file-once you have specified your preferences.

   Some coding systems can be recognized or distinguished by which byte
sequences appear in the data.  However, there are coding systems that
cannot be distinguished, not even potentially.  For example, there is no
way to distinguish between Latin-1 and Latin-2; they use the same byte
values with different meanings.

   Emacs handles this situation by means of a priority list of coding
systems.  Whenever Emacs reads a file, if you do not specify the coding
system to use, Emacs checks the data against each coding system,
starting with the first in priority and working down the list, until it
finds a coding system that fits the data.  Then it converts the file
contents assuming that they are represented in this coding system.

   The priority list of coding systems depends on the selected language
environment (*note Language Environments::.).  For example, if you use
French, you probably want Emacs to prefer Latin-1 to Latin-2; if you use
Czech, you probably want Latin-2 to be preferred.  This is one of the
reasons to specify a language environment.

   However, you can alter the priority list in detail with the command
`M-x prefer-coding-system'.  This command reads the name of a coding
system from the minibuffer, and adds it to the front of the priority
list, so that it is preferred to all others.  If you use this command
several times, each use adds one element to the front of the priority
list.

   Sometimes a file name indicates which coding system to use for the
file.  The variable `file-coding-system-alist' specifies this
correspondence.  There is a special function
`modify-coding-system-alist' for adding elements to this list.  For
example, to read and write all `.txt' using the coding system
`china-iso-8bit', you can execute this Lisp expression:

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

The first argument should be `file', the second argument should be a
regular expression that determines which files this applies to, and the
third argument says which coding system to use for these files.

   You can specify the coding system for a particular file using the
`-*-...-*-' construct at the beginning of a file, or a local variables
list at the end (*note File Variables::.).  You do this by defining a
value for the "variable" named `coding'.  Emacs does not really have a
variable `coding'; instead of setting a variable, it uses the specified
coding system for the file.  For example, `-*-mode: C; coding:
latin-1;-*-' specifies use of the Latin-1 coding system, as well as C
mode.

   Once Emacs has chosen a coding system for a buffer, it stores that
coding system in `buffer-file-coding-system' and uses that coding
system, by default, for operations that write from this buffer into a
file.  This includes the commands `save-buffer' and `write-region'.  If
you want to write files from this buffer using a different coding
system, you can specify a different coding system for the buffer using
`set-buffer-file-coding-system' (*note Specify Coding::.).

   When you send a message with Mail mode (*note Sending Mail::.),
Emacs has four different ways to determine the coding system to use for
encoding the message text.  It tries the buffer's own value of
`buffer-file-coding-system', if that is non-`nil'.  Otherwise, it uses
the value of `sendmail-coding-system', if that is non-`nil'.  The third
way is to use the default coding system for new files, which is
controlled by your choice of language environment, if that is
non-`nil'.  If all of these three values are `nil', Emacs encodes
outgoing mail using the Latin-1 coding system.

   When you get new mail in Rmail, each message is translated
automatically from the coding system it is written in--as if it were a
separate file.  This uses the priority list of coding systems that you
have specified.

   For reading and saving Rmail files themselves, Emacs uses the coding
system specified by the variable `rmail-file-coding-system'.  The
default value is `nil', which means that Rmail files are not translated
(they are read and written in the Emacs internal character code).


File: emacs,  Node: Specify Coding,  Next: Fontsets,  Prev: Recognize Coding,  Up: International

Specifying a Coding System
==========================

   In cases where Emacs does not automatically choose the right coding
system, you can use these commands to specify one:

`C-x <RET> f CODING <RET>'
     Use coding system CODING for the visited file in the current
     buffer.

`C-x <RET> c CODING <RET>'
     Specify coding system CODING for the immediately following command.

`C-x <RET> k CODING <RET>'
     Use coding system CODING for keyboard input.

`C-x <RET> t CODING <RET>'
     Use coding system CODING for terminal output.

`C-x <RET> p CODING <RET>'
     Use coding system CODING for subprocess input and output in the
     current buffer.

   The command `C-x RET f' (`set-buffer-file-coding-system') specifies
the file coding system for the current buffer--in other words, which
coding system to use when saving or rereading the visited file.  You
specify which coding system using the minibuffer.  Since this command
applies to a file you have already visited, it affects only the way the
file is saved.

   Another way to specify the coding system for a file is when you visit
the file.  First use the command `C-x <RET> c'
(`universal-coding-system-argument'); this command uses the minibuffer
to read a coding system name.  After you exit the minibuffer, the
specified coding system is used for *the immediately following command*.

   So if the immediately following command is `C-x C-f', for example,
it reads the file using that coding system (and records the coding
system for when the file is saved).  Or if the immediately following
command is `C-x C-w', it writes the file using that coding system.
Other file commands affected by a specified coding system include `C-x
C-i' and `C-x C-v', as well as the other-window variants of `C-x C-f'.

   `C-x <RET> c' also affects commands that start subprocesses,
including `M-x shell' (*note Shell::.).

   However, if the immediately following command does not use the coding
system, then `C-x <RET> c' ultimately has no effect.

   An easy way to visit a file with no conversion is with the `M-x
find-file-literally' command.  *Note Visiting::.

   The variable `default-buffer-file-coding-system' specifies the
choice of coding system to use when you create a new file.  It applies
when you find a new file, and when you create a buffer and then save it
in a file.  Selecting a language environment typically sets this
variable to a good choice of default coding system for that language
environment.

   The command `C-x <RET> t' (`set-terminal-coding-system') specifies
the coding system for terminal output.  If you specify a character code
for terminal output, all characters output to the terminal are
translated into that coding system.

   This feature is useful for certain character-only terminals built to
support specific languages or character sets--for example, European
terminals that support one of the ISO Latin character sets.

   By default, output to the terminal is not translated at all.

   The command `C-x <RET> k' (`set-keyboard-coding-system') specifies
the coding system for keyboard input.  Character-code translation of
keyboard input is useful for terminals with keys that send non-ASCII
graphic characters--for example, some terminals designed for ISO
Latin-1 or subsets of it.

   By default, keyboard input is not translated at all.

   There is a similarity between using a coding system translation for
keyboard input, and using an input method: both define sequences of
keyboard input that translate into single characters.  However, input
methods are designed to be convenient for interactive use by humans, and
the sequences that are translated are typically sequences of ASCII
printing characters.  Coding systems typically translate sequences of
non-graphic characters.

   The command `C-x <RET> p' (`set-buffer-process-coding-system')
specifies the coding system for input and output to a subprocess.  This
command applies to the current buffer; normally, each subprocess has its
own buffer, and thus you can use this command to specify translation to
and from a particular subprocess by giving the command in the
corresponding buffer.

   By default, process input and output are not translated at all.

   The variable `file-name-coding-system' specifies a coding system to
use for encoding file names.  If you set the variable to a coding
system name (as a Lisp symbol or a string), Emacs encodes file names
using that coding system for all file operations.  This makes it
possible to use non-ASCII characters in file names--or, at least, those
non-ASCII characters which the specified coding system can encode.  By
default, this variable is `nil', which implies that you cannot use
non-ASCII characters in file names.


File: emacs,  Node: Fontsets,  Next: Defining Fontsets,  Prev: Specify Coding,  Up: International

Fontsets
========

   A font for X Windows typically defines shapes for one alphabet or
script.  Therefore, displaying the entire range of scripts that Emacs
supports requires a collection of many fonts.  In Emacs, such a
collection is called a "fontset".  A fontset is defined by a list of
fonts, each assigned to handle a range of character codes.

   Each fontset has a name, like a font.  The available X fonts are
defined by the X server; fontsets, however, are defined within Emacs
itself.  Once you have defined a fontset, you can use it within Emacs by
specifying its name, anywhere that you could use a single font.  Of
course, Emacs fontsets can use only the fonts that the X server
supports; if certain characters appear on the screen as hollow boxes,
this means that the fontset in use for them has no font for those
characters.

   Emacs creates two fontsets automatically: the "standard fontset" and
the "startup fontset".  The standard fontset is most likely to have
fonts for a wide variety of non-ASCII characters; however, this is not
the default for Emacs to use.  (By default, Emacs tries to find a font
which has bold and italic variants.)  You can specify use of the
standard fontset by starting Emacs in this way:

     emacs -fn fontset-standard

   A fontset does not necessarily specify a font for all character
codes.  If a fontset specifies no font for a certain character, or if it
specifies a font that does not exist on your system, then it cannot
display that character.  It will display an empty box instead.

   The fontset height and width are determined by the ASCII characters
(that is, by the font used for ASCII characters in that fontset).  If
another font in the fontset has a different height, or a different
width, then characters assigned to that font are clipped to the
fontset's size.  If `highlight-wrong-size-font' is non-`nil', a box is
displayed around these wrong-size characters as well.


File: emacs,  Node: Defining Fontsets,  Next: Single-Byte European Support,  Prev: Fontsets,  Up: International

Defining fontsets
=================

   Emacs creates a standard fontset automatically according to the value
of `standard-fontset-spec'.  This fontset's name is

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

or just `fontset-standard' for short.

   Bold, italic, and bold-italic variants of the standard fontset are
created automatically.  Their names have `bold' instead of `medium', or
`i' instead of `r', or both.

   If you specify a default ASCII font with the `Font' resource or the
`-fn' argument, Emacs generates a fontset from it automatically.  This
is the "startup fontset" and its name is `fontsent-startup'.  It does
this by replacing the FOUNDRY, FAMILY, ADD_STYLE, and AVERAGE_WIDTH
fields of the font name with `*', replacing CHARSET_REGISTRY field with
`fontset', and replacing CHARSET_ENCODING field with `startup', then
using the resulting string to specify a fontset.

   For instance, if you start Emacs this way,

     emacs -fn *courier-medium-r-normal--14-140-*-iso8859-1

Emacs generates the following fontset and uses it for the initial X
window frame:

     -*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

   With the X resource `Emacs.Font', you can specify a fontset name
just like an actual font name.  But be careful not to specify a fontset
name in a wildcard resource like `Emacs*Font'--that wildcard
specification applies to various other purposes, such as menus, and
menus cannot handle fontsets.

   You can specify additional fontsets using X resources named
`Fontset-N', where N is an integer starting from 0.  The resource value
should have this form:

     FONTPATTERN, [CHARSETNAME:FONTNAME]...

FONTPATTERN should have the form of a standard X font name, except for
the last two fields.  They should have the form `fontset-ALIAS'.

   The fontset has two names, one long and one short.  The long name is
FONTPATTERN.  The short name is `fontset-ALIAS'.  You can refer to the
fontset by either name.

   The construct `CHARSET:FONT' specifies which font to use (in this
fontset) for one particular character set.  Here, CHARSET is the name
of a character set, and FONT is the font to use for that character set.
You can use this construct any number of times in defining one fontset.

   For the other character sets, Emacs chooses a font based on
FONTPATTERN.  It replaces `fontset-ALIAS' with values that describe the
character set.  For the ASCII character font, `fontset-ALIAS' is
replaced with `ISO8859-1'.

   In addition, when several consecutive fields are wildcards, Emacs
collapses them into a single wildcard.  This is to prevent use of
auto-scaled fonts.  Fonts made by scaling larger fonts are not usable
for editing, and scaling a smaller font is not useful because it is
better to use the smaller font in its own size, which Emacs does.

   Thus if FONTPATTERN is this,

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

the font specification for ASCII characters would be this:

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

and the font specification for Chinese GB2312 characters would be this:

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

   You may not have any Chinese font matching the above font
specification.  Most X distributions include only Chinese fonts that
have `song ti' or `fangsong ti' in FAMILY field.  In such a case,
`Fontset-N' can be specified as below:

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

Then, the font specifications for all but Chinese GB2312 characters have
`fixed' in the FAMILY field, and the font specification for Chinese
GB2312 characters has a wild card `*' in the FAMILY field.

   The function that processes the fontset resource value to create the
fontset is called `create-fontset-from-fontset-spec'.  You can also
call this function explicitly to create a fontset.

   *Note Font X::, for more information about font naming in X.


File: emacs,  Node: Single-Byte European Support,  Prev: Defining Fontsets,  Up: International

Single-byte European Character Support
======================================

   The ISO 8859 Latin-N character sets define character codes in the
range 160 to 255 to handle the accented letters and punctuation needed
by various European languages.  If you disable multibyte characters,
Emacs can still handle *one* of these character codes at a time.  To
specify *which* of these codes to use, call `set-language-environment'
and specify `Latin-N'.

   Emacs can display those characters provided the terminal or font in
use supports them.  Use the `M-x standard-display-european' command to
enable or disable European display mode.  With a numeric argument, `M-x
standard-display-european' enables European character display if and
only if the argument is positive.

   If your terminal does not support display of the Latin-1 character
set, Emacs can display these characters as ASCII sequences which at
least give you a clear idea of what the characters are.  To do this,
load the library `iso-ascii'.  Similar libraries for other Latin-N
character sets are possible, but we don't have them.

   There are three different ways you can input single-byte Latin-N
characters:

   * If your keyboard can generate character codes 128 and up,
     representing ISO Latin-N characters, execute the following
     expression to enable Emacs to understand them:

          (set-input-mode (car (current-input-mode))
                          (nth 1 (current-input-mode))
                          0)

   * For Latin-1 only, you can load the library `iso-transl' to turn the
     key `C-x 8' into a "compose character" prefix for entry of
     non-ASCII Latin-1 printing characters.  `C-x 8' is good for
     insertion (in the minibuffer as well as other buffers), for
     searching, and in any other context where a key sequence is
     allowed.  The <ALT> modifier key, if you have one, serves the same
     purpose as `C-x 8'; use <ALT> together with an accent character to
     modify the following letter.

   * You can use ISO Accents mode.  When this minor mode is enabled, the
     characters ``', `'', `"', `^', `/', `,' and `~' modify the
     following letter by adding the corresponding diacritical mark to
     it, if possible.  To enable or disable ISO Accents mode, use the
     command `M-x iso-accents-mode'.  This command affects only the
     current buffer.

     To enter one of those accent characters while in ISO Accents mode,
     type the character, followed by a space.  Some of those characters
     have a corresponding "dead key" accent character in certain ISO
     Latin character sets; to enter the "dead key" character, type the
     corresponding ASCII character twice.  For example, in Latin-1, `'''
     enters the Latin-1 character acute-accent (octal code 0264).

     ISO Accents mode input is available whenever a key sequence is
     expected: for ordinary insertion, for searching, for the
     minibuffer, and for certain command arguments.

     In addition to the accented letters, you can use these special
     sequences in ISO Accents mode to enter certain other ISO Latin-1
     characters:

          `/A', `A' with ring.  `~C', `C' with cedilla.  `~D', `D' with
          stroke.  `/E', `AE' ligature.  `/a', `a' with ring.  `~c',
          `c' with cedilla.  `~d', `d' with stroke.  `/e', `ae'
          ligature.  `"s', German sharp `s'.  `~<', left guillemot.
          `~>', right guillemot.  `~!', inverted exclamation mark.
          `~?', inverted question mark.


File: emacs,  Node: Major Modes,  Next: Indentation,  Prev: International,  Up: Top

Major Modes
***********

   Emacs provides many alternative "major modes", each of which
customizes Emacs for editing text of a particular sort.  The major modes
are mutually exclusive, and each buffer has one major mode at any time.
The mode line normally shows the name of the current major mode, in
parentheses (*note Mode Line::.).

   The least specialized major mode is called "Fundamental mode".  This
mode has no mode-specific redefinitions or variable settings, so that
each Emacs command behaves in its most general manner, and each option
is in its default state.  For editing text of a specific type that
Emacs knows about, such as Lisp code or English text, you should switch
to the appropriate major mode, such as Lisp mode or Text mode.

   Selecting a major mode changes the meanings of a few keys to become
more specifically adapted to the language being edited.  The ones that
are changed frequently are <TAB>, <DEL>, and `C-j'.  The prefix key
`C-c' normally contains mode-specific commands.  In addition, the
commands which handle comments use the mode to determine how comments
are to be delimited.  Many major modes redefine the syntactical
properties of characters appearing in the buffer.  *Note Syntax::.

   The major modes fall into three major groups.  Lisp mode (which has
several variants), C mode, Fortran mode and others are for specific
programming languages.  Text mode, Nroff mode, TeX mode and Outline
mode are for editing English text.  The remaining major modes are not
intended for use on users' files; they are used in buffers created for
specific purposes by Emacs, such as Dired mode for buffers made by Dired
(*note Dired::.), Mail mode for buffers made by `C-x m' (*note Sending
Mail::.), and Shell mode for buffers used for communicating with an
inferior shell process (*note Interactive Shell::.).

   Most programming-language major modes specify that only blank lines
separate paragraphs.  This is to make the paragraph commands useful.
(*Note Paragraphs::.)  They also cause Auto Fill mode to use the
definition of <TAB> to indent the new lines it creates.  This is
because most lines in a program are usually indented.  (*Note
Indentation::.)

* Menu:

* Choosing Modes::     How major modes are specified or chosen.


File: emacs,  Node: Choosing Modes,  Prev: Major Modes,  Up: Major Modes

How Major Modes are Chosen
==========================

   You can select a major mode explicitly for the current buffer, but
most of the time Emacs determines which mode to use based on the file
name or on special text in the file.

   Explicit selection of a new major mode is done with a `M-x' command.
From the name of a major mode, add `-mode' to get the name of a command
to select that mode.  Thus, you can enter Lisp mode by executing `M-x
lisp-mode'.

   When you visit a file, Emacs usually chooses the right major mode
based on the file's name.  For example, files whose names end in `.c'
are edited in C mode.  The correspondence between file names and major
modes is controlled by the variable `auto-mode-alist'.  Its value is a
list in which each element has this form,

     (REGEXP . MODE-FUNCTION)

or this form,

     (REGEXP MODE-FUNCTION FLAG)

For example, one element normally found in the list has the form
`("\\.c\\'" . c-mode)', and it is responsible for selecting C mode for
files whose names end in `.c'.  (Note that `\\' is needed in Lisp
syntax to include a `\' in the string, which is needed to suppress the
special meaning of `.' in regexps.)  If the element has the form
`(REGEXP MODE-FUNCTION FLAG)' and FLAG is non-nil, then after calling
FUNCTION, the suffix that matched REGEXP is discarded and the list is
searched again for another match.

   You can specify which major mode should be used for editing a certain
file by a special sort of text in the first nonblank line of the file.
The mode name should appear in this line both preceded and followed by
`-*-'.  Other text may appear on the line as well.  For example,

     ;-*-Lisp-*-

tells Emacs to use Lisp mode.  Such an explicit specification overrides
any defaulting based on the file name.  Note how the semicolon is used
to make Lisp treat this line as a comment.

   Another format of mode specification is

     -*- mode: MODENAME;-*-

which allows you to specify local variables as well, like this:

     -*- mode: MODENAME; VAR: VALUE; ... -*-

*Note File Variables::, for more information about this.

   When a file's contents begin with `#!', it can serve as an
executable shell command, which works by running an interpreter named on
the file's first line.  The rest of the file is used as input to the
interpreter.

   When you visit such a file in Emacs, if the file's name does not
specify a major mode, Emacs uses the interpreter name on the first line
to choose a mode.  If the first line is the name of a recognized
interpreter program, such as `perl' or `tcl', Emacs uses a mode
appropriate for programs for that interpreter.  The variable
`interpreter-mode-alist' specifies the correspondence between
interpreter program names and major modes.

   When you visit a file that does not specify a major mode to use, or
when you create a new buffer with `C-x b', the variable
`default-major-mode' specifies which major mode to use.  Normally its
value is the symbol `fundamental-mode', which specifies Fundamental
mode.  If `default-major-mode' is `nil', the major mode is taken from
the previously selected buffer.

   If you change the major mode of a buffer, you can go back to the
major mode Emacs would choose automatically: use the command `M-x
normal-mode' to do this.  This is the same function that `find-file'
calls to choose the major mode.  It also processes the file's local
variables list if any.

   The commands `C-x C-w' and `set-visited-file-name' change to a new
major mode if the new file name implies a mode (*note Saving::.).
However, this does not happen if the buffer contents specify a major
mode, and certain "special" major modes do not allow the mode to
change.  You can turn off this mode-changing feature by setting
`change-major-mode-with-file-name' to `nil'.


File: emacs,  Node: Indentation,  Next: Text,  Prev: Major Modes,  Up: Top

Indentation
***********

   This chapter describes the Emacs commands that add, remove, or
adjust indentation.

`<TAB>'
     Indent current line "appropriately" in a mode-dependent fashion.

`C-j'
     Perform <RET> followed by <TAB> (`newline-and-indent').

`M-^'
     Merge two lines (`delete-indentation').  This would cancel out the
     effect of `C-j'.

`C-M-o'
     Split line at point; text on the line after point becomes a new
     line indented to the same column that it now starts in
     (`split-line').

`M-m'
     Move (forward or back) to the first nonblank character on the
     current line (`back-to-indentation').

`C-M-\'
     Indent several lines to same column (`indent-region').

`C-x <TAB>'
     Shift block of lines rigidly right or left (`indent-rigidly').

`M-i'
     Indent from point to the next prespecified tab stop column
     (`tab-to-tab-stop').

`M-x indent-relative'
     Indent from point to under an indentation point in the previous
     line.

   Most programming languages have some indentation convention.  For
Lisp code, lines are indented according to their nesting in
parentheses.  The same general idea is used for C code, though many
details are different.

   Whatever the language, to indent a line, use the <TAB> command.  Each
major mode defines this command to perform the sort of indentation
appropriate for the particular language.  In Lisp mode, <TAB> aligns
the line according to its depth in parentheses.  No matter where in the
line you are when you type <TAB>, it aligns the line as a whole.  In C
mode, <TAB> implements a subtle and sophisticated indentation style that
knows about many aspects of C syntax.

   In Text mode, <TAB> runs the command `tab-to-tab-stop', which
indents to the next tab stop column.  You can set the tab stops with
`M-x edit-tab-stops'.

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.


File: emacs,  Node: Indentation Commands,  Next: Tab Stops,  Prev: Indentation,  Up: Indentation

Indentation Commands and Techniques
===================================

   To move over the indentation on a line, do `M-m'
(`back-to-indentation').  This command, given anywhere on a line,
positions point at the first nonblank character on the line.

   To insert an indented line before the current line, do `C-a C-o
<TAB>'.  To make an indented line after the current line, use `C-e C-j'.

   If you just want to insert a tab character in the buffer, you can
type `C-q <TAB>'.

   `C-M-o' (`split-line') moves the text from point to the end of the
line vertically down, so that the current line becomes two lines.
`C-M-o' first moves point forward over any spaces and tabs.  Then it
inserts after point a newline and enough indentation to reach the same
column point is on.  Point remains before the inserted newline; in this
regard, `C-M-o' resembles `C-o'.

   To join two lines cleanly, use the `M-^' (`delete-indentation')
command.  It deletes the indentation at the front of the current line,
and the line boundary as well, replacing them with a single space.  As
a special case (useful for Lisp code) the single space is omitted if
the characters to be joined are consecutive open parentheses or closing
parentheses, or if the junction follows another newline.  To delete
just the indentation of a line, go to the beginning of the line and use
`M-\' (`delete-horizontal-space'), which deletes all spaces and tabs
around the cursor.

   If you have a fill prefix, `M-^' deletes the fill prefix if it
appears after the newline that is deleted.  *Note Fill Prefix::.

   There are also commands for changing the indentation of several lines
at once.  `C-M-\' (`indent-region') applies to all the lines that begin
in the region; it indents each line in the "usual" way, as if you had
typed <TAB> at the beginning of the line.  A numeric argument specifies
the column to indent to, and each line is shifted left or right so that
its first nonblank character appears in that column.  `C-x <TAB>'
(`indent-rigidly') moves all of the lines in the region right by its
argument (left, for negative arguments).  The whole group of lines
moves rigidly sideways, which is how the command gets its name.

   `M-x indent-relative' indents at point based on the previous line
(actually, the last nonempty line).  It inserts whitespace at point,
moving point, until it is underneath an indentation point in the
previous line.  An indentation point is the end of a sequence of
whitespace or the end of the line.  If point is farther right than any
indentation point in the previous line, the whitespace before point is
deleted and the first indentation point then applicable is used.  If no
indentation point is applicable even then, `indent-relative' runs
`tab-to-tab-stop' (*note Tab Stops::.).

   `indent-relative' is the definition of <TAB> in Indented Text mode.
*Note Text::.

   *Note Format Indentation::, for another way of specifying the
indentation for part of your text.

