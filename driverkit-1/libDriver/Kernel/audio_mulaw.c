/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.1 (the "License").  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * audio_mulaw.c
 *
 * Copyright (c) 1992, NeXT Computer, Inc.  All rights reserved.
 *
 *	Mulaw conversion.
 *
 * HISTORY
 *	05/20/93/mtm	Original coding from sound library.
 */

#import <driverkit/generalFuncs.h>

/* FIXME: no prototype for kernel qsort */
extern qsort();

/*
 * Mulaw to 16 bit linear conversion table.
 */
#define	MULAWTABLEN	256
const short audio_muLaw[MULAWTABLEN] = {
 0x8284, 0x8684, 0x8a84, 0x8e84, 0x9284, 0x9684, 0x9a84, 0x9e84, 
 0xa284, 0xa684, 0xaa84, 0xae84, 0xb284, 0xb684, 0xba84, 0xbe84, 
 0xc184, 0xc384, 0xc584, 0xc784, 0xc984, 0xcb84, 0xcd84, 0xcf84, 
 0xd184, 0xd384, 0xd584, 0xd784, 0xd984, 0xdb84, 0xdd84, 0xdf84, 
 0xe104, 0xe204, 0xe304, 0xe404, 0xe504, 0xe604, 0xe704, 0xe804, 
 0xe904, 0xea04, 0xeb04, 0xec04, 0xed04, 0xee04, 0xef04, 0xf004, 
 0xf0c4, 0xf144, 0xf1c4, 0xf244, 0xf2c4, 0xf344, 0xf3c4, 0xf444, 
 0xf4c4, 0xf544, 0xf5c4, 0xf644, 0xf6c4, 0xf744, 0xf7c4, 0xf844, 
 0xf8a4, 0xf8e4, 0xf924, 0xf964, 0xf9a4, 0xf9e4, 0xfa24, 0xfa64, 
 0xfaa4, 0xfae4, 0xfb24, 0xfb64, 0xfba4, 0xfbe4, 0xfc24, 0xfc64, 
 0xfc94, 0xfcb4, 0xfcd4, 0xfcf4, 0xfd14, 0xfd34, 0xfd54, 0xfd74, 
 0xfd94, 0xfdb4, 0xfdd4, 0xfdf4, 0xfe14, 0xfe34, 0xfe54, 0xfe74, 
 0xfe8c, 0xfe9c, 0xfeac, 0xfebc, 0xfecc, 0xfedc, 0xfeec, 0xfefc, 
 0xff0c, 0xff1c, 0xff2c, 0xff3c, 0xff4c, 0xff5c, 0xff6c, 0xff7c, 
 0xff88, 0xff90, 0xff98, 0xffa0, 0xffa8, 0xffb0, 0xffb8, 0xffc0, 
 0xffc8, 0xffd0, 0xffd8, 0xffe0, 0xffe8, 0xfff0, 0xfff8, 0x0, 
 0x7d7c, 0x797c, 0x757c, 0x717c, 0x6d7c, 0x697c, 0x657c, 0x617c, 
 0x5d7c, 0x597c, 0x557c, 0x517c, 0x4d7c, 0x497c, 0x457c, 0x417c, 
 0x3e7c, 0x3c7c, 0x3a7c, 0x387c, 0x367c, 0x347c, 0x327c, 0x307c, 
 0x2e7c, 0x2c7c, 0x2a7c, 0x287c, 0x267c, 0x247c, 0x227c, 0x207c, 
 0x1efc, 0x1dfc, 0x1cfc, 0x1bfc, 0x1afc, 0x19fc, 0x18fc, 0x17fc, 
 0x16fc, 0x15fc, 0x14fc, 0x13fc, 0x12fc, 0x11fc, 0x10fc, 0xffc, 
 0xf3c, 0xebc, 0xe3c, 0xdbc, 0xd3c, 0xcbc, 0xc3c, 0xbbc, 
 0xb3c, 0xabc, 0xa3c, 0x9bc, 0x93c, 0x8bc, 0x83c, 0x7bc, 
 0x75c, 0x71c, 0x6dc, 0x69c, 0x65c, 0x61c, 0x5dc, 0x59c, 
 0x55c, 0x51c, 0x4dc, 0x49c, 0x45c, 0x41c, 0x3dc, 0x39c, 
 0x36c, 0x34c, 0x32c, 0x30c, 0x2ec, 0x2cc, 0x2ac, 0x28c, 
 0x26c, 0x24c, 0x22c, 0x20c, 0x1ec, 0x1cc, 0x1ac, 0x18c, 
 0x174, 0x164, 0x154, 0x144, 0x134, 0x124, 0x114, 0x104, 
 0xf4, 0xe4, 0xd4, 0xc4, 0xb4, 0xa4, 0x94, 0x84, 
 0x78, 0x70, 0x68, 0x60, 0x58, 0x50, 0x48, 0x40, 
 0x38, 0x30, 0x28, 0x20, 0x18, 0x10, 0x8, 0x0
};

#define IMULAWOFFSET	8192
#define	IMULAWTABLEN	16384
#define IMULAWMASK	16383

static unsigned char *iMuLaw = 0;

struct mu {
    short mu, linear;
};

static int compar(struct mu **p1, struct mu **p2)
{
    if ((*p1)->linear > (*p2)->linear) return 1;
    else if ((*p1)->linear == (*p2)->linear) return 0;
    else return -1;
}

void audio_makeIMuLawTab(void)
{
    int i,j,k, d1, d2;
    struct mu *mutab[256], mus[256];

    if (iMuLaw)
	return;

    iMuLaw = (unsigned char *)IOMalloc(IMULAWTABLEN * sizeof(unsigned char));

    for (i = 0; i < 256; ++i)
    {
	mutab[i] = &mus[i];
	mus[i].mu = i;
	mus[i].linear = audio_muLaw[i] >> 2;
    }
    qsort(mutab, 256, sizeof(struct mu *), compar);

    for (i = 0, j = 0, k = -8192; i < 16384; ++i, ++k)
    {
	if (j < 255)
	{
	    d1 = k - mutab[j]->linear;
	    d2 = mutab[j+1]->linear - k;
	    if (d1 > 0 && d1 > d2)
		++j;
	}
	iMuLaw[i] = mutab[j]->mu;
    }
}

void audio_freeIMuLawTab(void)
{
    if (iMuLaw)
	IOFree(iMuLaw, IMULAWTABLEN * sizeof(unsigned char));
}

unsigned char audio_shortToMulaw(short p)
{
    p >>= 2; /* scale input; table size is for 14 bit number! */

    if (p >= (IMULAWTABLEN/2))
	return iMuLaw[IMULAWTABLEN-1];
    if (p < (-IMULAWTABLEN/2))
	return iMuLaw[0];
    else
	return iMuLaw[p + IMULAWTABLEN/2];
}

unsigned char audio_byteToMulaw(char p)
{
    /* FIXME: shift up to 14 bits?? */

    return iMuLaw[p + IMULAWTABLEN/2];
}
