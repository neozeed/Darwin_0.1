/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.1 (the "License").  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1991 NeXT Computer, Inc.  All rights reserved. 
 *
 * unixDiskTypes.h
 *
 * HISTORY
 * 08-May-91    Doug Mitchell at NeXT
 *      Created.
 */

#ifndef	_UNIX_DISK_TYPES_
#define _UNIX_DISK_TYPES_

#import <driverkit/return.h>
#import <objc/objc.h>
#import <kernserv/queue.h>
#import "unixDisk.h"

#ifndef TRUE
#define TRUE    1
#endif  TRUE
#ifndef FALSE
#define FALSE   0
#endif  FALSE

/*
 * Representation of one I/O. This is generated by the device's exported
 * methods and enqueued on IOQueue to be serviced by the I/O thread.
 */
typedef struct IOBuf {

	SEL		command;	/* op to perform */
	u_int		offset;		/* block # */
	u_int		bytesReq;	/* bytes to move */
	void		*buf;		/* where to r/w */
	u_int		*bytesXfr;	/* bytes actually moved (RETURNED) */
	IOReturn	status;		/* result (RETURNED) */
	void 		*pending;	/* if non-zero, async request; this is
					 * used to ioComplete: the operation.
					 * Also ioKey for async DO ops.
					 */
	id		caller;		/* for async DO ops */
	id		wait_lock;	/* NXConditionLock - synchronous I/O
					 * waits on this condition. */
					 
	/*
	 * Fields written by device-specific dispatch code.
	 */
	id		device;		/* instance which owns this I/O */
	int		dirRead;	/* Written by command-specific code.
					 * Specifies direction of data 
					 * transfer. A hack which should go 
					 * away with RO support. */
	/*
	 * Queueing fields.
	 */
	queue_chain_t	ioChain;	/* for linking on IOQueue.queue */
	
} IOBuf_t;

/*
 * Queue of IOBufs. 
 */
typedef struct IOQueue {

	id	 	qlock;		/* NXConditionLock - protects this 
					 * struct; I/O thread blocks on this */
	queue_head_t	q_disk;		/* queue of IOBuf's needing disk */
	queue_head_t	q_nodisk;	/* queue of IOBuf's not needing disk */
	id		device;		/* owner of this queue */
	int		numThreads;	/* # of threads accessing this q */

	/*
	 * Eject command locking cruft. ejectLock is an NXConditionLock;
	 * its condition variable is the number of threads currently 
	 * executing commands from IOqueue.q_disk. An eject can only occur
	 * when this is 1.
	 *
	 * ejectPending is a hack; it shadows (lastReadyState == RS_EJECTING),
	 * but it's in sync with our I/O threads (volCheck's update of
	 * lastReadyState is not sunchronous with calls to 
	 * volCheckEjecting()...)
	 */
	id		ejectLock;		// NXConditionLock
	int		numDiskIos;		// #of threads executing 	
						// commands from 
						// IOqueue.q_disk
	boolean_t	ejectPending;
} IOQueue_t;

/*
 * Values for IOQueue.qlock condition variable.
 */
#define NO_WORK_AVAILABLE	0
#define WORK_AVAILABLE		1

#endif	_UNIX_DISK_TYPES_
