/*
 * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Portions Copyright (c) 1999 Apple Computer, Inc.  All Rights
 * Reserved.  This file contains Original Code and/or Modifications of
 * Original Code as defined in and that are subject to the Apple Public
 * Source License Version 1.1 (the "License").  You may not use this file
 * except in compliance with the License.  Please obtain a copy of the
 * License at http://www.apple.com/publicsource and read it before using
 * this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON- INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*	IOStubPrivate.h		1.0	02/07/91	(c) 1992 NeXT   
 *
 * IOStubPrivate.h - Private data structures for IOStub device.
 *
 * HISTORY
 * 19-Oct-92	Doug Mitchell at NeXT
 *      Created.
 */

#import "IOStub.h"
#import <driverkit/deviceCommon.h>
#import <objc/objc.h>
#import <kernserv/queue.h>
#import <mach/mach_types.h>
#import <driverkit/DeviceUxpr.h>

/*
 * Operations performed by IOStub's I/O thread.
 */
enum stub_cmd {STUB_READ, STUB_WRITE, STUB_ABORT };

/*
 * Representation of one I/O. This is generated by the device's exported
 * methods and enqueued on IOQueue to be serviced by the I/O thread.
 */
typedef struct _IOBuf {

	enum stub_cmd	cmd;		/* op to perform */
	u_int		offset;		/* block # */
	u_int		bytesReq;	/* bytes to move */
	void		*buf;		/* where to r/w */
	u_int		bytesXfr;	/* bytes actually moved (RETURNED) */
	IOReturn	status;		/* result (RETURNED) */
	void		*pending;	/* if non-NULL, async request; this is
					 * used to ioComplete: the operation.
					 * For kernel version, this is actually
					 * a struct buf */
	id		waitLock;	/* NXConditionLock. Sync I/O waits 
					 *    on this. */
	vm_task_t	client;		/* address space of *buf */

	/*
	 * Fields written by device-specific dispatch code.
	 */
	id		device;		/* instance which owns this I/O */
	int		dirRead;	/* Written by command-specific code.
					 * Specifies direction of data 
					 * transfer. A hack which should go 
					 * away with RO support. */
	/*
	 * Queueing fields.
	 */
	queue_chain_t	ioChain;	/* for linking on IOQueue.queue */
	
} IOBuf;

/*
 * Values for IOQueue.queueLock condition variable.
 */
#define NO_WORK_AVAILABLE	0
#define WORK_AVAILABLE		1

/*
 * bitmasks for xprMask.
 */
#define XPR_STUB	0x80000000

#define xpr_stub(x, a, b, c, d, e) 					\
	uxpr(XPR_IODEVICE_INDEX, XPR_STUB, x, a, b, c, d, e)
